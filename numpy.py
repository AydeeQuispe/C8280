# -*- coding: utf-8 -*-
"""Numpy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18AHMWFUBDSQ0OQafswN-LwNp3PK1bICR

## Numpy

NumPy es la librería central para computación científica en Python. Proporciona un objeto de matriz multidimensional de alto rendimiento y herramientas para trabajar con estas matrices.

#### Matrices

Una matriz NumPy es una colección de valores de tipos de datos similares y está indexada por una tupla de números no negativos. El rango de la matriz es el número de dimensiones, y la forma de una matriz es una tupla de números que dan el tamaño de la matriz a lo largo de cada dimensión.
"""

# Ejemplo
from __future__ import division
import time
import numpy as np


tam_vec = 1000
def lista_python():
    t1 = time.time()
    X = range(tam_vec)
    Y = range(tam_vec)
    Z = []
    for i in range(len(X)):
        Z.append(X[i] + Y[i])
    return time.time() - t1

def matriz_numpy():
    t1 = time.time()
    X = np.arange(tam_vec)
    Y = np.arange(tam_vec)
    Z = X + Y
    return time.time() - t1

# Completar

t1 = lista_python()
t2= matriz_numpy()
print(t1,t2)
print("este es el ejemplo " + str(t1/t2))

#import numpy
#numpy.__version__

"""Podemos inicializar matrices NumPy a partir de listas de Python anidadas y acceder a los elementos mediante corchetes."""

import numpy as np

# Creamos una matriz de rango 1
a = np.array([0, 1, 2])
print (type(a))

# Imprimimos la dimension de la matriz
print (a.shape)
print (a[0])
print (a[1])
print (a[2])

# Cambiamos un elemento de un array
a[0] = 5
print (a)

# Creamos una matriz de rango 2
b = np.array([[0,1,2],[3,4,5]])
print (b.shape)
print (b)
print (b[0, 0], b[0, 1], b[1, 0])

print ( b.shape)
print ( b[0, 0], b[0, 1], b[1, 0])

"""### Creación de una matriz NumPy

NumPy también proporciona muchas funciones integradas para crear matrices. La mejor manera de aprender esto es a través de ejemplos, así que pasemos al código.
"""

# Creamos una matriz 3x3 de todos ceros
a = np.zeros((3,3))
print (a)

# Creamos una matriz 2x2 de todos 1
b = np.ones((2,2))
print (b)

# Creamos una matriz 3x3 constantes
c = np.full((3,3), 7)
print(c)

# Creamos una matriz 3x3 con valores aleatorios
d = np.random.random((3,3))
print (d)

# Creamos una matriz identidad 3x3
e = np.eye(3)
print(e)

# Convertir una lista en una matriz
f = np.array([2, 3, 1,0])
print(f)

# arange() crea matrices con valores que se incrementan regularmente
# Completar
a = np.arange(1, 10, dtype=np.float64)
print(a)
b = np.arange(10, 20, dtype=np.int32)
print(b)

# Mezcla de tupla y listas
# Completar
import numpy as np
a = np.array([2, 3, 1,0],dtype=np.int32)
b = np.array((0, 3.2, 1,0))
c= np.array([a,b])
print(c)

# Crear una matriz de rango con tipo de datos flotante
i = np.arange(1, 8, dtype=np.float64)
print(i)

"""`linspace()`  crea matrices con un numero especifico de elementos que están espaciados por igual entre los valores inicial y final especificados"""

# Completa
a= np.linspace(10,50,15,dtype=np.int32)
print(a)

"""### Tipos de datos
Una matriz es una colección de elementos del mismo tipo de datos y NumPy admite y proporciona funciones integradas para construir matrices con argumentos opcionales para especificar explícitamente los tipos de datos requeridos.
"""

# Numpy escoge el tipo de datos
x = np.array([0, 1])
y = np.array([2.0, 3.0])

# Fuerza un tipo de datos en particular
z = np.array([5, 6], dtype=np.int64)
print (x.dtype, y.dtype, z.dtype)

"""**Ejercicio** Completa el siguiente  código."""

#np.random.seed(0)

x1 = np.random.randint(10, size=6)  # matriz 1-d
x2 = np.random.randint(10, size=(5, 4))  # matriz-2d
x3 = np.random.randint(10, size=(2, 4, 5)) # matriz-3d

# Imprime los atributos : dim, shape, size, dtype, itemsize y nbytes

# Completar
print(x1.ndim, x1.shape, x1.size,x1.dtype, x1.itemsize,x1.nbytes)
print(x2.ndim, x2.shape, x2.size,x2.dtype, x2.itemsize,x2.nbytes)
print(x3.ndim, x3.shape, x3.size,x3.dtype, x3.itemsize,x3.nbytes)

"""### Indexación de matrices

NumPy ofrece varias formas de indexar en matrices. La sintaxis estándar de Python `x[obj]` se puede usar para indexar la matriz NumPy, donde `x` es la matriz y `obj` es la selección.

Hay tres tipos de indexación disponibles:

* Acceso al campo

* Recorte básico

* Indexación avanzada

#### Acceso al campo

Si el objeto ndarray es una matriz estructurada, se puede acceder a los campos de la matriz indexando la matriz con cadenas, como un diccionario. La indexación de `x['field-name']` devuelve una nueva vista de la matriz, que tiene la misma dimensión que `x`, excepto cuando el campo es una submatriz  que contiene sólo la parte de los datos en el campo especificado. Los tipos de datos se obtienen con `x.dtype['field-name']`.
"""

x = np.zeros((3,3), dtype=[('a', np.int32), ('b', np.float64, (3,3))])
print(x)

print ("x['a'].shape: ",x['a'].shape)
print ("x['a'].dtype: ", x['a'].dtype)

print ("x['b'].shape: ", x['b'].shape)
print ("x['b'].dtype: ", x['b'].dtype)

"""#### Recorte básico

Las matrices NumPy se pueden dividir, de forma similar a las listas. Debe especificar un segmento para cada dimensión de la matriz, ya que las matrices pueden ser multidimensionales.

La sintaxis de división básica es `i: j: k`, donde `i` es el índice inicial, `j` es el índice final, `k` es el paso y `k` no es igual a 0. Esto selecciona los elementos `m` en la dimensión correspondiente, con valores de índice `, i + k, ...,i + (m - 1)k` donde `m = q + (r distinto de 0)`,  `q` y `r` son el cociente y el resto se obtiene dividiendo `j - i` entre `k`: `j - i = qk + r`, de modo que `i + (m - 1) k < j`.
"""

x = np.array([5, 6, 7, 8, 9])
x[1:7:2]

"""La `k` negativa hace que los pasos vayan hacia índices más pequeños. Los `i` y `j` negativos se interpretan como `n + i` y `n + j` donde `n` es el número de elementos en la dimensión correspondiente."""

print (x[-2:5])
print (x[-1:1:-1])

"""Si `n` es el número de elementos en la dimensión que se está recortando. Entonces, si no se proporciona `i`, el valor predeterminado es `0` para  `k > 0` y `n-1` para `k < 0`. Si no se proporciona `j`, el valor predeterminado es `n` para `k > 0` y `-1` para `k < 0`. Si no se proporciona `k`, el valor predeterminado es `1`. Ten en cuenta que `::` es lo mismo que `:` y significa seleccionar todos los índices a lo largo de este eje."""

x[4:]

"""Si el número de objetos en la tupla de selección es menor que N , entonces se asume `:` para cualquier dimensión subsiguiente."""

# Completar

"""Los puntos suspensivos se expanden al número de : objetos necesarios para hacer una tupla de selección de la misma longitud que `x.ndim`. Solo puede haber una sola elipsis presente."""

print(x)

x[...,0]

"""#### Ejercicio

1. Crea una matriz de rango `2` con dimension `(3, 4)`

2. Usa el recorte para extraer la submatriz que consta de las primeras `2` filas y las columnas `1` y `2`.

3. Una parte de una matriz es solo una vista de los mismos datos, comprueba quecualquier modificación modificará la matriz original.


"""

# Tu respuesta
matriz = np.array([[8.2,2,3.2,4.11], [5,6,7,8], [9,10,11,12]])
print("Matriz original:")
print(matriz)
print()

# Extraer la submatriz de las primeras 2 filas y columnas 1 y 2
submatriz = matriz[:2, 1:3]
print("Submatriz:")
print(submatriz)
print()

# Modificar la submatriz
submatriz[0, 0] = 99
print("Submatriz modificada:")
print(submatriz)
print()

# Verificar que la matriz original también se modifica
print("Matriz original después de modificar la submatriz:")
print(matriz)

"""Se puede acceder a la matriz de la fila central de dos maneras.

* Las partes junto con la indexación de enteros darán como resultado una matriz de rango inferior.

* El uso de solo recortes dará como resultado el mismo rango matriz.
"""

# Creamos una matriz de rango 2 array con dimensión (3, 4)
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
print (a)

"""Dos formas de acceder a los datos en la fila central de la matriz. La combinación de la indexación de enteros con recortes produce una matriz de menor rango, mientras que el uso de solo recortes produce una matriz del mismo rango que la matriz original:"""

fila_r1 = a[1, :]    # Vista de rango 1 de la segunda fila de a
fila_r2 = a[1:2, :]  # Vista de rango 2 de la segunda fila de a
fila_r3 = a[[1], :]  # Vista de ranfo 2 de la segunda fila de a
print (fila_r1, fila_r1.shape)
print (fila_r2, fila_r2.shape)
print (fila_r3, fila_r3.shape)

"""Podemos hacer la misma distinción al acceder a las columnas de una matriz."""

col_r1 = a[:, 1]
col_r2 = a[:, 1:2]
print (col_r1, col_r1.shape)
print (col_r2, col_r2.shape)

"""### Indexación avanzada

"""

a = np.array([[1,2], [3, 4]])
print (a[[0, 1], [0, 1]])

# El ejemplo de indexacion de una matriz entera es equivalente a esto:
# completar

"""Al usar la indexacion de un matriz de enteros, puede reutilizar el mismo elemento de la matriz de origen:"""

print (a[[0, 0], [1, 1]])

# Equivalente al ejemplo de indexacion de matriz de enteros
# completar

"""Un asunto  importante y extremadamente útil acerca de los recortes de una  matriz es que devuelven  *vistas (`views`)* en lugar de *copias (`copies`)*  de los datos de la matriz. Este es un área en la que NumPy  difiere de la lista de Python:  en las listas, estas son copias."""

np.random.seed(0)
x2 = np.random.randint(10, size=(5, 4))
x2

x2_sub = x2[:2, :2]
print(x2_sub)

x2_sub[0, 0] = 99
print(x2_sub)

"""Este comportamiento predeterminado es realmente muy útil: significa que cuando trabajamos con grandes conjuntos de datos, podemos acceder y procesar partes de estos conjuntos de datos sin necesidad de copiar el búfer de datos.

A pesar de las características  de las `vistas` de una  matriz, a veces es útil copiar de forma explícita los datos dentro de una matriz o una submatriz. Esto se puede hacer  con el método `copy()`:
"""

x2_sub_copy = x2[:2, :2].copy()
print(x2_sub_copy)

x2_sub_copy[0, 0] = 42
print(x2_sub_copy)

print(x2)

"""### Reshaping"""

x4 = np.arange(1, 10).reshape((3, 3))
print(x4)

"""Ten en cuenta que para que esto funcione, el tamaño de la matriz inicial debe coincidir con el tamaño de la matriz rediseñada. Siempre que sea posible, el método `reshape` utilizará una `vista` sin copia de la matriz inicial.

Otro patrón de `reshaping `, es la conversión de una matriz unidimensional en una fila o columna de una matriz bidimensional. Esto se puede hacer con el método `reshape`  o más fácilmente haciendo uso de `newaxis` dentro de una operación de división:
"""

x5 = np.array([1, 2, 3])
x5

# vector fila via reshape
# completar

# vector fila con newaxis
# completar

# vector columna via reshape
# completar

# vector columna con newaxis
# completar

"""### Concatenación y  separación

"""

x = np.array([4, 5, 6])
y = np.array([7, 8, 9])
np.concatenate([x, y])

# concatenacion de dos o mas matrices
z = [99, 99, 99]
print(np.concatenate([x, y, z]))

# concatendo una matriz dos veces
grid = np.array([[1, 2, 3],
                 [4, 5, 6]])
np.concatenate([grid, grid])

"""Para trabajar con matrices de distintas dimensiones, se usan las funciones `vstack` y `hstack`:"""

x = np.array([0, 1, 2])
grid = np.array([[3, 4, 5],
                 [6, 5, 4]])

# Se junta la matriz de manera vertical
# Completar

# Se junta la matriz de manera horizontal
y = np.array([[23],
              [23]])
# Completar

"""Lo contrario de la concatenación es la división o separación, que es implementado por las funciones `np.split`, `np.hsplit` y `np.vsplit`. Para cada uno de estas funciones , podemos pasar una lista de índices que dan los puntos de división.

Ver:[https://numpy.org/doc/stable/reference/generated/numpy.split.html](https://numpy.org/doc/stable/reference/generated/numpy.split.html)
"""

x = [1, 2, 3, 44, 95, 3, 2, 1]
x1, x2, x3 = np.split(x, [3, 5])
print(x1, x2, x3)

grid = np.arange(16).reshape((4, 4))
grid

grid1, grid2 = np.vsplit(grid, [2])
print(grid1)
print(grid2)

grid3, grid4 = np.hsplit(grid,[2])
print(grid3)
print(grid4)

"""### Fancy

"""

rand = np.random.RandomState(42)
x = rand.randint(100, size=10)
print(x)

# Accedemos a tres elementos diferentes
[x[1], x[5], x[2]]

"""Alternativamente, podemos pasar una sola lista o matriz de índices para obtener el mismo resultado:"""

X = np.array([[11,12 , 33],
              [14, 15, 16],
              [17, 18, 19]])

indices_filas = np.array([0, 2])
indices_columnas = np.array([1, 2])

X[indices_filas, indices_columnas]

"""Cuando se utiliza fancy, la forma del resultado refleja la forma de las matrices de índice en lugar de la forma de la matriz que se indexa y trabaja  en múltiples  dimensiones:"""

# Completar

X = np.arange(12).reshape((3, 4))
X

"""Al igual que con la indexación estándar, el primer índice se refiere a la fila, y el segundo a la columna:"""

fila = np.array([0, 1, 2])
col = np.array([2, 1, 3])
X[fila, col]

"""Observa que el primer valor en el resultado es `X[0, 2]`, el segundo es `X[1, 1]`  y el tercero es `X[2, 3]`. El emparejamiento de índices en la indexación fancy  sigue todas las reglas del broadcasting, por ejemplo, si combinamos un vector de columna y un vector de fila dentro de los índices, obtenemos un resultado bidimensional:"""

# Completar

"""Aquí, cada valor de fila se empareja con cada vector de columna, exactamente como se hace en broadcasting  de operaciones aritméticas. Por ejemplo:"""

# Completar

"""Siempre es importante recordar que en  la indexación fancy, el valor de retorno refleja la forma del broadcasting  de los índices, en lugar de la forma de la matriz que se indexa.

Para operaciones  más potentes, la indexación adornada se puede combinar con los otros esquemas de indexación que existen:
"""

# print(X)

# Combinando el indexado fancy y indices simples
# Completar

# Combinando el indexado fancy y el recorte
# Completar

"""Así como el fancy  se puede utilizar para acceder a partes de una matriz, también se puede utilizar para modificar partes de una matriz. Por ejemplo, si  tenemos una matriz de índices y nos gustaría establecer los elementos correspondientes en una matriz a algún valor, podemos hacer lo siguiente:"""

x = np.arange(10)
i = np.array([2, 1, 8, 4])
x[i] = 99
print(x)

"""Los índices repetidos con estas operaciones pueden causar algunos resultados potencialmente inesperados. Considera lo siguiente:"""

x = np.zeros(10)
x[[0, 0]] = [4, 6]
print(x)

"""El resultado de esta operación es asignar primero  `x[0] = 4`, seguido por `x[0] = 6`. Pero el resultado es que `x[0]` contiene el valor 6.

Considera la siguiente operación:
"""

i = [2, 3, 3, 4, 4, 4]
x[i] += 1
x

"""En este caso algún resultado inesperado se debe conceptualmente  a que `x[i] +=1` se entiende como una abreviatura de `x[i] = x [i] + 1`. Cuando `x[i] + 1` es evaluado el resultado es asignado  a los índices en `x` . Con esto en mente, no es que el aumento que ocurre varias veces, sino la asignación, que conduce a los resultados  no intuitivos.

Si quieremos  el otro comportamiento donde se repite la operación, se puede utilizar el método `at()` de `ufuncs`:
"""

# Completar

"""El método `at()` realiza una aplicación  del operador dado en los índices especificados (aquí, `i`) con el valor especificado (aquí, `1`).

###  Expresiones vectorizadas

### Agregaciones
"""

L = np.random.random(100)
sum(L)

"""La sintaxis es bastante similar a la función de `sum` de  `NumPy`  y el resultado es el mismo en el caso más simple:"""

np.sum(L)

"""Sin embargo, debido a que la operación se ejecuta  en código compilado, la versión `NumPy` de la operación se calcula mucho más rápidamente:"""

# Commented out IPython magic to ensure Python compatibility.
matriz_grande = np.random.rand(1000000)
# %timeit sum(matriz_grande)
# %timeit np.sum(matriz_grande)

"""La función `sum` y la función `np.sum` no son idénticas, lo que a veces puede conducir a la confusión.  En particular, sus argumentos opcionales tienen significados diferentes  y `np.sum` es válido a  varias dimensiones de una matriz."""

# Otras funciones min y max
min(matriz_grande), max(matriz_grande)

# Commented out IPython magic to ensure Python compatibility.
# %timeit min(matriz_grande)
# %timeit np.min(matriz_grande)

"""Todas estas funciones también están disponibles como métodos en la clase `ndarray`. Por ejemplo, `np.mean(data)` y `data.mean()` en el ejemplo siguiente son equivalentes:"""

data = np.random.normal(size=(15, 15))
np.mean(data)

data.mean()

"""Un tipo común de operación de agregación es un agregado a lo largo de una fila o columna."""

M = np.random.random((5, 6))
print(M)

"""De forma predeterminada, cada función de agregación de  `NumPy`  devolverá el agregado sobre toda la matriz:"""

M.sum()

"""Las funciones de agregación toman un argumento adicional que especifica el eje a lo largo del cual se calcula el agregado. Por ejemplo, podemos encontrar el valor de la suma y el  mínimo de cada columna especificando `axis = 0`:"""

M.sum(axis= 0)

data = np.random.normal(size=(5, 10, 15))
data.sum(axis=0).shape

data.sum(axis=(0, 2)).shape

data.sum()

"""Algunas funciones de agregación en `Numpy ` son :


|Nombre de funcion  | VersionNaN-safe     | Descripcion                                   |
|-------------------|---------------------|-----------------------------------------------|
| ``np.sum``        | ``np.nansum``       | Calcula suma de elementos                     |
| ``np.prod``       | ``np.nanprod``      | Calcula el producto de elementos              |
| ``np.mean``       | ``np.nanmean``      | Calcula la media de elementos                 |
| ``np.std``        | ``np.nanstd``       | Calcula la desviacion estandar                |
| ``np.var``        | ``np.nanvar``       | Calcula la  varianza                          |
| ``np.min``        | ``np.nanmin``       | Encuentra el minimo valor                     |
| ``np.max``        | ``np.nanmax``       | Encuentra el maximo valor                     |
| ``np.argmin``     | ``np.nanargmin``    | Encuenta el index del minimo valor            |
| ``np.argmax``     | ``np.nanargmax``    | Encuentra el index del maximo valor           |
| ``np.median``     | ``np.nanmedian``    | Calcula la mediana de elementos               |
| ``np.percentile`` | ``np.nanpercentile``| Calcula el rango estatistico de elementos     |
| ``np.any``        | N/A                 | Evalua si algun elemento es true              |
| ``np.all``        | N/A                 | Evalua si todos los elementos son true        |

#### Broadcasting
"""

a = np.array([0, 1, 2])
b = np.array([2, 6, 1])
a + b

"""El  `broadcasting` permite que estos tipos de operaciones binarias se realicen en matrices de diferentes tamaños; por ejemplo, podemos añadir  un escalar (una matriz de dimensión cero) a una matriz:"""

a + 5

"""Podemos extender de manera similar esto a matrices de mayor dimensión. Veamos el resultado cuando agregamos una matriz unidimensional a una matriz bidimensional:"""

A = np.arange(16).reshape(4, 4)
b = np.arange(4)
A

A + b

"""Podemos aplicar el  `broadcasting` en dos matrices. Considere el siguiente ejemplo:"""

# Completar
# Suma entre una matriz y un vector
A = np.array([[1, 2, 3],
              [4, 5, 6]])

vector = np.array([1, 2, 3])
A + vector

# Multiplicación entre una matriz y un escalar

D = np.array([[1, 2, 3],
              [4, 5, 6]])

escalar = 2
D * escalar

# Suma entre una matriz y una matriz de una sola fila

import numpy as np

A = np.array([[1, 2, 3],
              [4, 5, 6]])

B = np.array([[1, 2, 3]])

A + B

# Completar
C = np.array([[1, 2, 3],
              [4, 5, 6]])

vector = np.array([1, 2, 3])

C * vector

"""###  Regla del broadcasting

El `broadcasting` en `NumPy` sigue un estricto conjunto de reglas para determinar la interacción entre dos matrices :

* Regla 1: Si las dos matrices difieren en su número de dimensiones, la forma de la matriz que tiene menos dimensiones se rellena con unos en el lado principal (izquierdo).

* Regla 2: Si la forma de los dos matrices no coincide con ninguna dimensión, la matriz con la forma igual a 1 en esa dimensión se estira para que coincida con la otra dimensión.

* Regla 3: Si en cualquier dimensión los tamaños son distintos y ninguno es igual a 1, se genera un error.

### Un útil truco:
"""

J = np.arange(0, 40, 10)
J.shape

J = J[:, np.newaxis]  # agregamos un nuevo eje ->  matriz 2D
J.shape

J

J + 3

"""### Comparaciones, máscaras y lógica Booleana

"""

a1 = np.array([1, 2, 3, 4])
b1 = np.array([4, 3, 2, 1])
a1 < b1

np.all(a1 < b1)

np.any(a1 < b1)

if np.all(a1 < b1):
    print(" Todos los elementos en a1 son menores que los elementos en b1 ")
elif np.any(a1 < b1):
    print("Algunos elementos en a1 son menores que los elementos de b1")
else:
    print("Todos los elementos en b1 son menores que los elementos de a1")

"""Al aparecer en una expresión aritmética junto con un número escalar, u otra matriz `NumPy` con un tipo de datos numéricos, una matriz booleana se convierte en una matriz numérica con valores `0` y `1` en lugar de `False` y `True`, respectivamente."""

# Completar

# Completar

# Completar

"""Esta es una propiedad útil para la computación condicional, como cuando se definen funciones."""

#def pulso(t, posicion, altura, ancho):
#    return altura * (t >= posicion) * (t <= (posicion + ancho))
# Completar

"""### Matrices booleanas como máscaras

Revisar: [masked array](https://docs.scipy.org/doc/numpy/reference/maskedarray.html).
"""

k = np.array([1, 3, -1, 5, 7, -1])
mask = (k < 0)
mask

# Un ejemplo bidimensional
rng = np.random.RandomState(0)
z1 = rng.randint(10, size=(3, 4))
z1

# Completar

"""Ahora, para seleccionar estos valores de la matriz, podemos simplemente indexar en esta matriz booleana, esto se conoce como una operación de `enmascaramiento`:"""

# Completar

"""El siguiente ejemplo muestra cómo sumar la matriz de enmascaramiento,  donde `True` representa uno y `False` representa 0."""

# Completar

"""### Lectura recomendada: [Numpy Reference](https://docs.scipy.org/doc/numpy/reference/)."""

